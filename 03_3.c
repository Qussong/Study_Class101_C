/*
*	26:50
*		<< 2의 보수 표현과 오버플로우 >>	
* 
*		[ 정수의 2의 보수 표현 ] 
*	- 음수 표현을 2의 보수로 하는 방식
*	- '2의 보수'란...
*		[원리] 완전수를 2로 하는 보수 체계
*		[방법] 1의 보수에 1을 더하여 얻어짐
*	
*	컴퓨터의 메모리는 2진수 형태로 되어있다.
*	양수의 경우 10진법의 수를 2진법으로 변환하면 되지만...
*	음수의 표현은...? 컴퓨터에선 음수의 표현의 '2의 보수'라는 형태로 한다.
*	
*	보수를 알기전에 '완전수'에 대해서 알아야 한다.
*	ex_1)
*	10을 완전수라고 하며 3의 보수는 7, 4의 보수는 6이 된다.
*	
*	2의 보수일때 완전수의 의미는...
*	가지고 있는 모든 bit가 0이고 그 위에 한개의 1이 붙어있는 값을 완전수로 하고
*	해당 상탱에서의 보수를 의미한다.
*	ex_2)
*	1byte 기준 완전수는 100000000(2) 이며...
*	10진수 3은 2진수로 00000011(2) 이며 보수는 11111100(2) 이다.
*	
*	하지만 위의 방법은 복잡해보일 수 있다. 때문에 1의 보수에 1을 더하여 얻는 방법을 사용한다.
*	'1의 보수'란 "2의 보수의 완전수 보다 하나 작은 수"를 완전수로 보는 것
*	즉, 1byte 기준 1의 보수는 '11111111' 이 된다.
*	ex_3)
*	10진수 3의 1의 보수는 11111100(2) 즉, 3을 2지수로 나타냈을 떄의 값인 00000011(2)을
*	반대로 뒤집어 주면 된다.
*	그리고 빼주었던 1을 다시 더하면 2의 보수인 11111101(2)이 된다. 
*	이는 10진수로 -3 을 의미한다.
* 
*	2의 보수에서 제일 첫번째 bit 는 MSB로써 0 이면 '양수' 1이면 '음수'를 의미한다.
*	1의 보수를 활용하여 구한 -3의 2의 보수 체계에서 다시 원래의 값을 구하는 방법은...
*	
*	ex_4)
*	1. 2의 보수를 보아 11111101(2) 의 첫번째 비트가 1이기에 음수임을 확인하였다.
*	2. 해당 값의 1의 보수를 구한 후 +1 을 해준다.
*		00000010(2) + 1 = 00000011(2) = 3
*	3. 음수임을 확인했기에 부호 변경해준다.
*	4. 11111101(2) 가 2의 보수일때 의미하는 값이 -3 임을 알 수 있다.
*	 
*/

#include <stdio.h>

void main() {
	/*
	* 사용하는 수의 범위가 4만 이하일꺼라는 전제로 short int 를 사용
	* int 는 4byte = 32개의 bit 로 정수를 표현한다.
	* short int 는 2byte = 16개의 bit 로 정수를 표현한다.
	* 이때, 16개의 bit 중 제일 앞의 MSB 는 '부호Bit' 역할을 하기에
	* 15개의 bit로 숫자의 크기를 표현한다.
	* 2^15 = 32768 이며 0 부터 표현하기에 32767 까지 표현할 수 있다.
	*/
	short int number = 32000;

	printf("%d\n", number);  // 32000
	number += 767;
	printf("%d\n", number);  // 32767

	/*
	*	short int 가 표현할 수 있는 값의 범위를 벗어남으로 인해 
	*	'오버 플로우'가 발생했다.
	*	오버 플로우가 발생하면... MSB 의 값이 변하는 특징이 생긴다.
	*	때문에 음수가 반환된다.
	*	실제로도 사용하고자 하는 값의 영역이 작다면 int 앞에 short를 붙여주는 것이 좋으나
	*	사용하고자 하는 값의 범위가 short int 가 표현할 수 있는 값의 범위를 벗어나는 경우
	*	오버 플로우가 발생하니 주의하자. 해당 경우 설정한 값의 타입의 최대 표현 가능한 수의
	*	버위를 인지하고 오버 플로우가 발생했음을 파악해야한다.
	*/
	number = 32000;
	number += 768;
	printf("%d\n", number);  // -32768
	number = 32000;
	number += 10000;
	printf("%d", number);  // -23536
}
